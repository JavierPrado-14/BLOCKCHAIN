#!/usr/bin/env python3
"""
Dashboard con IA para Blockchain Corda
Dashboard interactivo con an√°lisis avanzados y capacidades de IA
"""

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import psycopg2
import numpy as np
from datetime import datetime, timedelta
import json
from sklearn.ensemble import IsolationForest
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
import google.generativeai as genai
import time
import threading
import queue
import warnings
warnings.filterwarnings('ignore')

# ===== Configuraci√≥n de Gemini =====
GEMINI_API_KEY = "AIzaSyBM5jwwPLcn9aldmaypSP-ywvqecVfJEIA"
genai.configure(api_key=GEMINI_API_KEY)

# Configuraci√≥n de la p√°gina
st.set_page_config(
    page_title="Corda Blockchain Dashboard",
    page_icon="üîó",
    layout="wide",
    initial_sidebar_state="expanded"
)

# CSS personalizado para el dashboard
st.markdown("""
<style>
    .main-header {
        font-size: 3rem;
        color: #1f77b4;
        text-align: center;
        margin-bottom: 2rem;
    }
    .metric-card {
        background-color: #f0f2f6;
        padding: 1rem;
        border-radius: 0.5rem;
        border-left: 4px solid #1f77b4;
    }
    .ai-section {
        background-color: #e8f4fd;
        padding: 1rem;
        border-radius: 0.5rem;
        border: 1px solid #1f77b4;
    }
</style>
""", unsafe_allow_html=True)

class CordaDashboard:
    """Dashboard principal para an√°lisis de datos de Corda"""
    
    def __init__(self):
        """Inicializar el dashboard"""
        self.db_config = {
            'host': 'dpg-d3hk1u33fgac739s7s9g-a.oregon-postgres.render.com',
            'port': 5432,
            'database': 'blokchain_bd',
            'user': 'blokchain_bd_user',
            'password': 'RlxkDsSrWcte8ASrxsztagJWod7qNrWP'
        }
        self.data = None
        self.model = genai.GenerativeModel('gemini-2.5-flash')
        self.load_data()
    
    def load_data(self, time_filter=None, limit=None):
        """Cargar datos desde PostgreSQL con filtros din√°micos"""
        try:
            conn = psycopg2.connect(**self.db_config)
            
            # Construir query din√°mico
            base_query = """
            SELECT 
                id, timestamp, state_type, participants, amount, currency, 
                status, block_height, network, notary, contract, flow_id,
                extraction_timestamp, processed, processing_timestamp
            FROM corda_transactions
            """
            
            where_conditions = []
            params = []
            
            # Filtro de tiempo din√°mico
            if time_filter:
                if time_filter == "last_hour":
                    where_conditions.append("timestamp >= NOW() - INTERVAL '1 hour'")
                elif time_filter == "last_24h":
                    where_conditions.append("timestamp >= NOW() - INTERVAL '24 hours'")
                elif time_filter == "last_7d":
                    where_conditions.append("timestamp >= NOW() - INTERVAL '7 days'")
                elif time_filter == "last_30d":
                    where_conditions.append("timestamp >= NOW() - INTERVAL '30 days'")
                elif time_filter == "real_time":
                    # Solo transacciones de los √∫ltimos 5 minutos para an√°lisis en tiempo real
                    where_conditions.append("timestamp >= NOW() - INTERVAL '5 minutes'")
            
            # Agregar condiciones WHERE si existen
            if where_conditions:
                base_query += " WHERE " + " AND ".join(where_conditions)
            
            # Ordenar por timestamp descendente
            base_query += " ORDER BY timestamp DESC"
            
            # Agregar LIMIT si se especifica
            if limit:
                base_query += f" LIMIT {limit}"
            
            # Ejecutar query
            self.data = pd.read_sql_query(base_query, conn)
            conn.close()
            
            if not self.data.empty:
                # Procesar datos
                self.data['timestamp'] = pd.to_datetime(self.data['timestamp'])
                self.data['amount_numeric'] = pd.to_numeric(self.data['amount'], errors='coerce')
                self.data['date'] = self.data['timestamp'].dt.date
                self.data['hour'] = self.data['timestamp'].dt.hour
                self.data['day_of_week'] = self.data['timestamp'].dt.day_name()
                self.data['minute'] = self.data['timestamp'].dt.minute
                
                # Agregar timestamp de carga
                self.data['loaded_at'] = datetime.now()
            
        except Exception as e:
            st.error(f"Error cargando datos: {str(e)}")
            self.data = pd.DataFrame()
    
    def get_realtime_stats(self):
        """Obtener estad√≠sticas en tiempo real"""
        try:
            conn = psycopg2.connect(**self.db_config)
            
            # Query para estad√≠sticas en tiempo real
            stats_query = """
            SELECT 
                COUNT(*) as total_transactions,
                COUNT(CASE WHEN timestamp >= NOW() - INTERVAL '1 hour' THEN 1 END) as last_hour,
                COUNT(CASE WHEN timestamp >= NOW() - INTERVAL '24 hours' THEN 1 END) as last_24h,
                COALESCE(SUM(CASE WHEN timestamp >= NOW() - INTERVAL '24 hours' THEN amount::numeric END), 0) as total_amount_24h,
                COALESCE(AVG(CASE WHEN timestamp >= NOW() - INTERVAL '24 hours' THEN amount::numeric END), 0) as avg_amount_24h,
                MAX(timestamp) as last_transaction
            FROM corda_transactions
            """
            
            stats = pd.read_sql_query(stats_query, conn)
            conn.close()
            
            return stats.iloc[0].to_dict()
            
        except Exception as e:
            st.error(f"Error obteniendo estad√≠sticas: {str(e)}")
            return {}
    
    def render_header(self):
        """Renderizar encabezado del dashboard"""
        col1, col2 = st.columns([4, 1])
        
        with col1:
            st.markdown('<h1 class="main-header">üîó Corda Blockchain Dashboard</h1>', unsafe_allow_html=True)
            st.markdown("### An√°lisis en Tiempo Real con Inteligencia Artificial")
        
        with col2:
            st.markdown("<br>", unsafe_allow_html=True)
            if st.button("üîÑ Actualizar Datos", use_container_width=True, type="primary"):
                with st.spinner("Actualizando datos..."):
                    # Cargar datos sin filtro de tiempo para obtener todos los datos
                    self.load_data()
                    st.rerun()
        
        # Estad√≠sticas en tiempo real
        realtime_stats = self.get_realtime_stats()
        
        if realtime_stats:
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                st.metric(
                    "üìä Total Transacciones",
                    f"{realtime_stats.get('total_transactions', 0):,}",
                    delta=None
                )
            
            with col2:
                st.metric(
                    "‚è∞ √öltima Hora",
                    f"{realtime_stats.get('last_hour', 0):,}",
                    delta=None
                )
            
            with col3:
                st.metric(
                    "üìà √öltimas 24h",
                    f"{realtime_stats.get('last_24h', 0):,}",
                    delta=None
                )
            
            with col4:
                last_tx = realtime_stats.get('last_transaction', 'N/A')
                if last_tx != 'N/A':
                    last_tx = pd.to_datetime(last_tx)
                    time_diff = datetime.now() - last_tx
                    if time_diff.total_seconds() < 60:
                        status = "üü¢ Activo"
                    elif time_diff.total_seconds() < 300:
                        status = "üü° Reciente"
                    else:
                        status = "üî¥ Inactivo"
                else:
                    status = "‚ùå Sin datos"
                
                st.metric(
                    "üîÑ Estado",
                    status,
                    delta=None
                )
            
            st.info(f"üí° √öltima transacci√≥n: {realtime_stats.get('last_transaction', 'N/A')}")
        
        if not self.data.empty:
            st.success(f"‚úÖ {len(self.data)} transacciones cargadas - √öltima actualizaci√≥n: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        else:
            st.error("‚ùå No se pudieron cargar los datos")
    
    def render_metrics(self):
        """Renderizar m√©tricas principales"""
        if self.data.empty:
            return
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            total_amount = self.data['amount_numeric'].sum()
            st.metric(
                "üí∞ Monto Total",
                f"${total_amount:,.2f}",
                delta=None
            )
        
        with col2:
            avg_amount = self.data['amount_numeric'].mean()
            st.metric(
                "üìä Monto Promedio",
                f"${avg_amount:,.2f}",
                delta=None
            )
        
        with col3:
            total_transactions = len(self.data)
            st.metric(
                "üìà Total Transacciones",
                f"{total_transactions:,}",
                delta=None
            )
        
        with col4:
            unique_currencies = self.data['currency'].nunique()
            st.metric(
                "üí± Monedas",
                f"{unique_currencies}",
                delta=None
            )
    
    def render_time_series_analysis(self):
        """An√°lisis de series temporales"""
        st.header("üìà An√°lisis de Series Temporales")
        
        if self.data.empty:
            return
        
        # Agrupar por fecha
        daily_data = self.data.groupby('date').agg({
            'amount_numeric': ['sum', 'count', 'mean'],
            'id': 'count'
        }).round(2)
        
        daily_data.columns = ['Total_Amount', 'Transaction_Count', 'Avg_Amount', 'Total_Transactions']
        daily_data = daily_data.reset_index()
        
        # Gr√°fico de evoluci√≥n temporal
        fig = make_subplots(
            rows=2, cols=2,
            subplot_titles=('Evoluci√≥n del Monto Total', 'N√∫mero de Transacciones', 
                          'Monto Promedio por D√≠a', 'Distribuci√≥n por Hora'),
            specs=[[{"secondary_y": False}, {"secondary_y": False}],
                   [{"secondary_y": False}, {"secondary_y": False}]]
        )
        
        # Monto total por d√≠a
        fig.add_trace(
            go.Scatter(x=daily_data['date'], y=daily_data['Total_Amount'], 
                      name='Monto Total', line=dict(color='#1f77b4')),
            row=1, col=1
        )
        
        # N√∫mero de transacciones por d√≠a
        fig.add_trace(
            go.Scatter(x=daily_data['date'], y=daily_data['Transaction_Count'], 
                      name='Transacciones', line=dict(color='#ff7f0e')),
            row=1, col=2
        )
        
        # Monto promedio por d√≠a
        fig.add_trace(
            go.Scatter(x=daily_data['date'], y=daily_data['Avg_Amount'], 
                      name='Monto Promedio', line=dict(color='#2ca02c')),
            row=2, col=1
        )
        
        # Distribuci√≥n por hora
        hourly_dist = self.data.groupby('hour').size()
        fig.add_trace(
            go.Bar(x=hourly_dist.index, y=hourly_dist.values, 
                   name='Por Hora', marker_color='#d62728'),
            row=2, col=2
        )
        
        fig.update_layout(height=600, showlegend=True, title_text="An√°lisis Temporal de Transacciones")
        st.plotly_chart(fig, use_container_width=True)
    
    def generate_gemini_insights(self):
        """Generar insights usando Gemini AI con an√°lisis din√°mico"""
        if self.data.empty:
            return None
        
        try:
            # Determinar el contexto temporal de los datos
            time_range = self.data['timestamp'].max() - self.data['timestamp'].min()
            hours_range = time_range.total_seconds() / 3600
            
            # Contexto temporal
            if hours_range < 1:
                time_context = "√∫ltimos minutos (an√°lisis en tiempo real)"
            elif hours_range < 24:
                time_context = f"√∫ltimas {hours_range:.1f} horas"
            elif hours_range < 168:  # 7 d√≠as
                time_context = f"√∫ltimos {hours_range/24:.1f} d√≠as"
            else:
                time_context = f"√∫ltimos {hours_range/24:.0f} d√≠as"
            
            # Estad√≠sticas din√°micas
            latest_tx = self.data['timestamp'].max()
            oldest_tx = self.data['timestamp'].min()
            time_since_latest = datetime.now() - latest_tx
            
            # Preparar resumen din√°mico para Gemini
            summary = f"""
Analiza los siguientes datos de transacciones de blockchain Corda de los {time_context} y proporciona insights valiosos:

CONTEXTO TEMPORAL:
- Per√≠odo analizado: {time_context}
- √öltima transacci√≥n: {latest_tx}
- Tiempo desde √∫ltima transacci√≥n: {time_since_latest.total_seconds():.0f} segundos
- Rango completo: {oldest_tx} a {latest_tx}

ESTAD√çSTICAS ACTUALES:
- Total de transacciones: {len(self.data)}
- Monto total: ${self.data['amount_numeric'].sum():,.2f}
- Monto promedio: ${self.data['amount_numeric'].mean():,.2f}
- Monto m√°ximo: ${self.data['amount_numeric'].max():,.2f}
- Monto m√≠nimo: ${self.data['amount_numeric'].min():,.2f}

DISTRIBUCI√ìN POR MONEDA:
{self.data['currency'].value_counts().to_dict()}

DISTRIBUCI√ìN POR ESTADO:
{self.data['status'].value_counts().to_dict()}

DISTRIBUCI√ìN POR TIPO DE ESTADO:
{self.data['state_type'].value_counts().to_dict()}

PATRONES TEMPORALES ESPEC√çFICOS:
- Transacciones por hora: {self.data.groupby('hour').size().to_dict()}
- Transacciones por d√≠a: {self.data.groupby('date').size().to_dict()}
- Horas m√°s activas: {self.data.groupby('hour').size().nlargest(3).to_dict()}
- D√≠as m√°s activos: {self.data.groupby('day_of_week').size().nlargest(3).to_dict()}

ACTIVIDAD RECIENTE:
- Transacciones en √∫ltima hora: {len(self.data[self.data['timestamp'] >= latest_tx - timedelta(hours=1)])}
- Transacciones en √∫ltimos 10 minutos: {len(self.data[self.data['timestamp'] >= latest_tx - timedelta(minutes=10)])}

Por favor proporciona un an√°lisis espec√≠fico para este per√≠odo temporal:
1. **An√°lisis de actividad actual**: ¬øQu√© tan activo est√° el sistema ahora?
2. **Patrones identificados**: ¬øQu√© patrones √∫nicos ves en este per√≠odo?
3. **Tendencias temporales**: ¬øC√≥mo ha cambiado la actividad en este tiempo?
4. **Anomal√≠as detectadas**: ¬øHay comportamientos inusuales o transacciones sospechosas?
5. **Recomendaciones inmediatas**: ¬øQu√© acciones se deber√≠an tomar basadas en estos datos?
6. **Predicciones a corto plazo**: ¬øQu√© esperas que pase en las pr√≥ximas horas?

Responde en espa√±ol, enf√≥cate en la relevancia temporal y proporciona insights accionables.
"""
            
            # Generar respuesta con Gemini
            response = self.model.generate_content(summary)
            return response.text
            
        except Exception as e:
            st.error(f"Error al generar insights con Gemini: {str(e)}")
            return None
    
    def render_gemini_insights(self):
        """Renderizar insights generados por Gemini AI"""
        st.header("üß† Insights Generados por IA (Gemini)")
        
        if self.data.empty:
            st.warning("No hay datos disponibles para an√°lisis")
            return
        
        # Mostrar contexto temporal de los datos
        if not self.data.empty:
            latest_tx = self.data['timestamp'].max()
            oldest_tx = self.data['timestamp'].min()
            time_range = latest_tx - oldest_tx
            time_since_latest = datetime.now() - latest_tx
            
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("üìä Transacciones Analizadas", len(self.data))
            with col2:
                st.metric("‚è∞ Rango Temporal", f"{time_range.days}d {time_range.seconds//3600}h")
            with col3:
                st.metric("üïê √öltima Actividad", f"{time_since_latest.total_seconds():.0f}s")
        
        col1, col2 = st.columns([4, 1])
        
        with col2:
            generate_button = st.button("‚ú® Generar An√°lisis IA", use_container_width=True, type="primary")
            
            # Bot√≥n para regenerar con datos actualizados
            if 'gemini_insights' in st.session_state:
                regenerate_button = st.button("üîÑ Regenerar An√°lisis", use_container_width=True)
                if regenerate_button:
                    # Limpiar insights anteriores
                    if 'gemini_insights' in st.session_state:
                        del st.session_state.gemini_insights
        
        # Generar insights si se solicita o si no existen
        if generate_button or 'gemini_insights' not in st.session_state:
            with st.spinner("ü§ñ Gemini AI est√° analizando los datos en tiempo real..."):
                insights = self.generate_gemini_insights()
                if insights:
                    st.session_state.gemini_insights = insights
                    st.session_state.gemini_generated_at = datetime.now()
        
        # Mostrar insights si existen
        if 'gemini_insights' in st.session_state:
            st.markdown('<div class="ai-section">', unsafe_allow_html=True)
            
            # Header con informaci√≥n del an√°lisis
            generated_at = st.session_state.get('gemini_generated_at', datetime.now())
            st.markdown(f"### üìä An√°lisis Inteligente - {generated_at.strftime('%Y-%m-%d %H:%M:%S')}")
            
            # Mostrar insights
            st.markdown(st.session_state.gemini_insights)
            st.markdown('</div>', unsafe_allow_html=True)
            
            # Informaci√≥n adicional
            col1, col2 = st.columns(2)
            with col1:
                st.caption(f"üïê An√°lisis generado: {generated_at.strftime('%Y-%m-%d %H:%M:%S')}")
            with col2:
                st.caption(f"üìä Basado en {len(self.data)} transacciones")
                
            # Bot√≥n para limpiar cache
            if st.button("üóëÔ∏è Limpiar An√°lisis", help="Elimina el an√°lisis actual para generar uno nuevo"):
                if 'gemini_insights' in st.session_state:
                    del st.session_state.gemini_insights
                if 'gemini_generated_at' in st.session_state:
                    del st.session_state.gemini_generated_at
                st.rerun()
        else:
            st.info("üëÜ Haz clic en 'Generar An√°lisis IA' para obtener insights inteligentes sobre tus datos")
    
    def render_ai_analysis(self):
        """An√°lisis con Inteligencia Artificial"""
        st.header("ü§ñ An√°lisis con Machine Learning")
        
        if self.data.empty:
            return
        
        # Preparar datos para ML
        ml_data = self.data[['amount_numeric', 'hour', 'day_of_week']].copy()
        ml_data['day_of_week_num'] = pd.Categorical(ml_data['day_of_week']).codes
        ml_data = ml_data.dropna()
        
        if len(ml_data) < 10:
            st.warning("No hay suficientes datos para an√°lisis de IA")
            return
        
        # An√°lisis de anomal√≠as
        st.subheader("üîç Detecci√≥n de Anomal√≠as")
        
        # Preparar caracter√≠sticas
        features = ml_data[['amount_numeric', 'hour', 'day_of_week_num']]
        scaler = StandardScaler()
        features_scaled = scaler.fit_transform(features)
        
        # Detectar anomal√≠as
        isolation_forest = IsolationForest(contamination=0.1, random_state=42)
        anomaly_labels = isolation_forest.fit_predict(features_scaled)
        
        # Agregar etiquetas a los datos
        ml_data['anomaly'] = anomaly_labels
        anomalies = ml_data[ml_data['anomaly'] == -1]
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.metric("üö® Anomal√≠as Detectadas", f"{len(anomalies)}")
        
        with col2:
            anomaly_rate = len(anomalies) / len(ml_data) * 100
            st.metric("üìä Tasa de Anomal√≠as", f"{anomaly_rate:.1f}%")
        
        # Visualizar anomal√≠as
        fig_anomalies = px.scatter(
            ml_data, x='amount_numeric', y='hour',
            color='anomaly', 
            title='Detecci√≥n de Anomal√≠as en Transacciones',
            labels={'amount_numeric': 'Monto', 'hour': 'Hora del D√≠a'},
            color_discrete_map={1: 'blue', -1: 'red'}
        )
        st.plotly_chart(fig_anomalies, use_container_width=True)
        
        # Clustering
        st.subheader("üéØ An√°lisis de Clusters")
        
        # Aplicar K-means
        kmeans = KMeans(n_clusters=3, random_state=42)
        clusters = kmeans.fit_predict(features_scaled)
        ml_data['cluster'] = clusters
        
        # Visualizar clusters
        fig_clusters = px.scatter_3d(
            ml_data, x='amount_numeric', y='hour', z='day_of_week_num',
            color='cluster',
            title='Clustering de Transacciones',
            labels={'amount_numeric': 'Monto', 'hour': 'Hora', 'day_of_week_num': 'D√≠a de la Semana'}
        )
        st.plotly_chart(fig_clusters, use_container_width=True)
        
        # Mostrar detalles de anomal√≠as
        if len(anomalies) > 0:
            st.subheader("üìã Detalles de Anomal√≠as Detectadas")
            anomaly_details = self.data[self.data.index.isin(anomalies.index)]
            st.dataframe(anomaly_details[['id', 'timestamp', 'amount', 'currency', 'state_type', 'status']])
    
    def render_currency_analysis(self):
        """An√°lisis por moneda"""
        st.header("üí± An√°lisis por Moneda")
        
        if self.data.empty:
            return
        
        col1, col2 = st.columns(2)
        
        with col1:
            # Distribuci√≥n por moneda
            currency_dist = self.data['currency'].value_counts()
            fig_currency = px.pie(
                values=currency_dist.values, 
                names=currency_dist.index,
                title="Distribuci√≥n por Moneda"
            )
            st.plotly_chart(fig_currency, use_container_width=True)
        
        with col2:
            # Monto total por moneda
            currency_amount = self.data.groupby('currency')['amount_numeric'].sum().sort_values(ascending=False)
            fig_amount = px.bar(
                x=currency_amount.index, 
                y=currency_amount.values,
                title="Monto Total por Moneda",
                labels={'x': 'Moneda', 'y': 'Monto Total'}
            )
            st.plotly_chart(fig_amount, use_container_width=True)
    
    def render_state_analysis(self):
        """An√°lisis por tipo de estado"""
        st.header("üèõÔ∏è An√°lisis por Tipo de Estado")
        
        if self.data.empty:
            return
        
        col1, col2 = st.columns(2)
        
        with col1:
            # Distribuci√≥n por tipo de estado
            state_dist = self.data['state_type'].value_counts()
            fig_state = px.bar(
                x=state_dist.index, 
                y=state_dist.values,
                title="Distribuci√≥n por Tipo de Estado",
                labels={'x': 'Tipo de Estado', 'y': 'N√∫mero de Transacciones'}
            )
            fig_state.update_layout(xaxis_tickangle=45)
            st.plotly_chart(fig_state, use_container_width=True)
        
        with col2:
            # Monto promedio por tipo de estado
            state_amount = self.data.groupby('state_type')['amount_numeric'].mean().sort_values(ascending=False)
            fig_state_amount = px.bar(
                x=state_amount.index, 
                y=state_amount.values,
                title="Monto Promedio por Tipo de Estado",
                labels={'x': 'Tipo de Estado', 'y': 'Monto Promedio'}
            )
            fig_state_amount.update_layout(xaxis_tickangle=45)
            st.plotly_chart(fig_state_amount, use_container_width=True)
    
    def render_status_analysis(self):
        """An√°lisis por estado de transacci√≥n"""
        st.header("üìä An√°lisis por Estado de Transacci√≥n")
        
        if self.data.empty:
            return
        
        col1, col2 = st.columns(2)
        
        with col1:
            # Distribuci√≥n por estado
            status_dist = self.data['status'].value_counts()
            fig_status = px.pie(
                values=status_dist.values, 
                names=status_dist.index,
                title="Distribuci√≥n por Estado"
            )
            st.plotly_chart(fig_status, use_container_width=True)
        
        with col2:
            # Tasa de √©xito por tipo de estado
            success_rate = self.data.groupby('state_type')['status'].apply(
                lambda x: (x == 'CONFIRMED').sum() / len(x) * 100
            ).sort_values(ascending=False)
            
            fig_success = px.bar(
                x=success_rate.index, 
                y=success_rate.values,
                title="Tasa de √âxito por Tipo de Estado (%)",
                labels={'x': 'Tipo de Estado', 'y': 'Tasa de √âxito (%)'}
            )
            fig_success.update_layout(xaxis_tickangle=45)
            st.plotly_chart(fig_success, use_container_width=True)
    
    def render_realtime_controls(self):
        """Controles de tiempo real"""
        st.sidebar.header("‚è∞ Controles de Tiempo Real")
        
        # Selector de modo de an√°lisis
        analysis_mode = st.sidebar.selectbox(
            "üéØ Modo de An√°lisis",
            options=[
                "üìä Todos los Datos",
                "‚è∞ √öltima Hora",
                "üìà √öltimas 24 Horas", 
                "üìÖ √öltimos 7 D√≠as",
                "üóìÔ∏è √öltimos 30 D√≠as",
                "üî• Tiempo Real (5 min)"
            ],
            index=0
        )
        
        # Mapear opciones a filtros
        time_filters = {
            "üìä Todos los Datos": None,
            "‚è∞ √öltima Hora": "last_hour",
            "üìà √öltimas 24 Horas": "last_24h",
            "üìÖ √öltimos 7 D√≠as": "last_7d",
            "üóìÔ∏è √öltimos 30 D√≠as": "last_30d",
            "üî• Tiempo Real (5 min)": "real_time"
        }
        
        selected_filter = time_filters[analysis_mode]
        
        # Auto-refresh toggle
        auto_refresh = st.sidebar.checkbox("üîÑ Auto-actualizaci√≥n", value=False)
        
        if auto_refresh:
            refresh_interval = st.sidebar.slider(
                "‚è±Ô∏è Intervalo (segundos)",
                min_value=10,
                max_value=300,
                value=60,
                step=10
            )
            
            # Mostrar countdown
            if 'last_refresh' not in st.session_state:
                st.session_state.last_refresh = time.time()
            
            time_since_refresh = time.time() - st.session_state.last_refresh
            time_until_next = refresh_interval - time_since_refresh
            
            if time_until_next > 0:
                st.sidebar.info(f"üïê Pr√≥xima actualizaci√≥n en: {int(time_until_next)}s")
            else:
                st.sidebar.success("üîÑ Actualizando autom√°ticamente...")
                st.session_state.last_refresh = time.time()
                # Recargar datos con filtro seleccionado
                self.load_data(time_filter=selected_filter)
                st.rerun()
        
        # Bot√≥n para aplicar filtro manualmente
        if st.sidebar.button("üéØ Aplicar Filtro", use_container_width=True):
            with st.spinner(f"Cargando datos: {analysis_mode}..."):
                self.load_data(time_filter=selected_filter)
                st.rerun()
        
        return selected_filter
    
    def render_interactive_filters(self):
        """Filtros interactivos"""
        st.sidebar.header("üîß Filtros Interactivos")
        
        if self.data.empty:
            return
        
        # Filtro por fecha
        date_range = st.sidebar.date_input(
            "Rango de Fechas",
            value=(self.data['date'].min(), self.data['date'].max()),
            min_value=self.data['date'].min(),
            max_value=self.data['date'].max()
        )
        
        # Filtro por moneda
        currencies = st.sidebar.multiselect(
            "Monedas",
            options=self.data['currency'].unique(),
            default=self.data['currency'].unique()
        )
        
        # Filtro por tipo de estado
        state_types = st.sidebar.multiselect(
            "Tipos de Estado",
            options=self.data['state_type'].unique(),
            default=self.data['state_type'].unique()
        )
        
        # Filtro por estado de transacci√≥n
        statuses = st.sidebar.multiselect(
            "Estados de Transacci√≥n",
            options=self.data['status'].unique(),
            default=self.data['status'].unique()
        )
        
        # Filtro por rango de monto
        amount_range = st.sidebar.slider(
            "Rango de Monto",
            min_value=float(self.data['amount_numeric'].min()),
            max_value=float(self.data['amount_numeric'].max()),
            value=(float(self.data['amount_numeric'].min()), float(self.data['amount_numeric'].max()))
        )
        
        # Aplicar filtros
        filtered_data = self.data[
            (self.data['date'] >= date_range[0]) & 
            (self.data['date'] <= date_range[1]) &
            (self.data['currency'].isin(currencies)) &
            (self.data['state_type'].isin(state_types)) &
            (self.data['status'].isin(statuses)) &
            (self.data['amount_numeric'] >= amount_range[0]) &
            (self.data['amount_numeric'] <= amount_range[1])
        ]
        
        st.sidebar.metric("Transacciones Filtradas", len(filtered_data))
        
        return filtered_data
    
    def render_export_options(self):
        """Opciones de exportaci√≥n"""
        st.sidebar.header("üì§ Exportar Datos")
        
        if self.data.empty:
            return
        
        # Exportar a CSV
        csv = self.data.to_csv(index=False)
        st.sidebar.download_button(
            label="üìä Descargar CSV",
            data=csv,
            file_name=f"corda_data_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
            mime="text/csv"
        )
        
        # Exportar a JSON
        json_data = self.data.to_json(orient='records', date_format='iso')
        st.sidebar.download_button(
            label="üìÑ Descargar JSON",
            data=json_data,
            file_name=f"corda_data_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
            mime="application/json"
        )
    
    def run(self):
        """Ejecutar el dashboard completo"""
        # Renderizar encabezado con estad√≠sticas en tiempo real
        self.render_header()
        
        # Renderizar controles de tiempo real
        selected_time_filter = self.render_realtime_controls()
        
        # Renderizar m√©tricas principales
        self.render_metrics()
        
        # Renderizar filtros interactivos
        filtered_data = self.render_interactive_filters()
        
        # Renderizar opciones de exportaci√≥n
        self.render_export_options()
        
        # Renderizar an√°lisis
        if not filtered_data.empty:
            # Secci√≥n de IA Generativa con Gemini (primera)
            self.render_gemini_insights()
            
            st.markdown("---")
            
            # An√°lisis tradicionales
            self.render_time_series_analysis()
            self.render_currency_analysis()
            self.render_state_analysis()
            self.render_status_analysis()
            
            # An√°lisis de Machine Learning
            self.render_ai_analysis()
        else:
            st.warning("No hay datos que coincidan con los filtros seleccionados")
            
            # Si no hay datos filtrados pero hay datos en general, mostrar mensaje
            if not self.data.empty:
                st.info("üí° Prueba cambiar los filtros o seleccionar un rango de tiempo diferente")
            else:
                st.error("‚ùå No hay datos disponibles. Verifica la conexi√≥n a la base de datos.")

def main():
    """Funci√≥n principal"""
    dashboard = CordaDashboard()
    dashboard.run()

if __name__ == "__main__":
    main()
